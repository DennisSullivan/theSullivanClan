<!DOCTYPE html>
<html lang="en">
<head>
<meta charset="UTF-8">
<meta name="viewport" content="width=device-width, initial-scale=1.0">
<title>KenKen 6×6 • SullivanClan</title>

<style>
  body {
    background: #fff8ec;
    font-family: "Trebuchet MS", sans-serif;
    margin: 0;
    padding: 0;
    text-align: center;
  }

  header {
    background: linear-gradient(135deg, #ffb36b, #ff8a5c);
    color: white;
    padding: 22px;
    font-size: 30px;
    font-weight: bold;
    letter-spacing: 1px;
    box-shadow: 0 3px 6px rgba(0,0,0,0.25);
  }

  .container {
    max-width: 500px;
    margin: 20px auto;
    padding: 10px;
  }

  select, button {
    width: 90%;
    padding: 14px;
    font-size: 18px;
    border-radius: 10px;
    margin-bottom: 15px;
  }

  select {
    border: 2px solid #ffb36b;
    background: #fffdf7;
  }

  button {
    background: #6bb8ff;
    color: white;
    border: none;
    box-shadow: 0 3px 5px rgba(0,0,0,0.25);
    cursor: pointer;
  }

  button:hover {
    background: #4aa6ff;
    transform: scale(1.03);
  }

  /* Square responsive grid */
  #kenken {
    width: 100%;
    max-width: 420px;
    aspect-ratio: 1 / 1;
    margin: 0 auto;
    border-collapse: collapse;
  }

  #kenken td {
    position: relative;
    padding: 0;
    border: 1px solid #5a3e2b;
    background: #fff8ec; /* match the page */
    width: calc(100% / 6);
    height: calc(100% / 6);
  }

  /* Rounded, dark-brown cage borders on every cell */
  .cage-top {
    border-top: 4px solid #5a3e2b !important;
    border-top-left-radius: 10px;
    border-top-right-radius: 10px;
  }
  .cage-bottom {
    border-bottom: 4px solid #5a3e2b !important;
    border-bottom-left-radius: 10px;
    border-bottom-right-radius: 10px;
  }
  .cage-left {
    border-left: 4px solid #5a3e2b !important;
    border-top-left-radius: 10px;
    border-bottom-left-radius: 10px;
  }
  .cage-right {
    border-right: 4px solid #5a3e2b !important;
    border-top-right-radius: 10px;
    border-bottom-right-radius: 10px;
  }

  /* Inputs: transparent so borders are visible */
  #kenken input {
    width: 100%;
    height: 100%;
    border: none;
    background: transparent;
    text-align: center;
    font-size: 22px;
    font-weight: bold;
    padding: 0;
    margin: 0;
  }

  #kenken input:focus {
    outline: 2px solid #ffb36b;
  }

  .cage-label {
    position: absolute;
    top: 2px;
    left: 4px;
    font-size: 12px;
    color: #5a3e2b;
    font-weight: bold;
    pointer-events: none;
  }

  #message {
    margin-top: 10px;
    font-size: 17px;
  }

  .back-link {
    display: inline-block;
    margin-top: 25px;
    color: #444;
    font-size: 18px;
    text-decoration: none;
  }
</style>
</head>

<body>

<header>KenKen 6×6</header>

<div class="container">

  <p>Select difficulty and generate a new puzzle.</p>

  <select id="difficulty">
    <option value="gentle">Gentle</option>
    <option value="moderate">Moderate</option>
    <option value="challenging">Challenging</option>
  </select>

  <button onclick="generatePuzzle()">Generate Puzzle</button>

  <table id="kenken"></table>

  <button onclick="checkKenKen()">Check My Solution</button>
  <div id="message"></div>

  <a class="back-link" href="index.html">← Back to Puzzles</a>

</div>

<script>
/* ---------------------------------------------------------
   LATIN SQUARE GENERATOR
   --------------------------------------------------------- */
function generateLatinSquare(n) {
  const grid = [];
  for (let r = 0; r < n; r++) {
    grid[r] = [];
    for (let c = 0; c < n; c++) {
      grid[r][c] = ((r + c) % n) + 1;
    }
  }
  return grid;
}

function shuffleRows(grid) {
  for (let i = grid.length - 1; i > 0; i--) {
    const j = Math.floor(Math.random() * (i + 1));
    [grid[i], grid[j]] = [grid[j], grid[i]];
  }
}

function shuffleCols(grid) {
  const n = grid.length;
  for (let c = n - 1; c > 0; c--) {
    const j = Math.floor(Math.random() * (c + 1));
    for (let r = 0; r < n; r++) {
      [grid[r][c], grid[r][j]] = [grid[r][j], grid[r][c]];
    }
  }
}

/* ---------------------------------------------------------
   CAGE GENERATOR WITH CORRECT OP RULES
   --------------------------------------------------------- */
function generateCages(solution, difficulty) {
  const n = 6;
  const cages = [];
  const used = Array.from({ length: n }, () => Array(n).fill(false));

  const settings = {
    gentle:   { maxSize: 2, ops: ["+","-"] },
    moderate: { maxSize: 3, ops: ["+","-","×","÷"] },
    challenging: { maxSize: 4, ops: ["+","-","×","÷"] } // but filtered by size below
  };

  const { maxSize, ops } = settings[difficulty];

  for (let r = 0; r < n; r++) {
    for (let c = 0; c < n; c++) {
      if (used[r][c]) continue;

      const cage = { cells: [[r,c]] };
      used[r][c] = true;

      // Grow cage up to maxSize
      let size = 1;
      while (size < maxSize) {
        const neighbors = [];

        cage.cells.forEach(([rr,cc]) => {
          [[1,0],[-1,0],[0,1],[0,-1]].forEach(([dr,dc]) => {
            const nr = rr + dr, nc = cc + dc;
            if (nr >= 0 && nr < n && nc >= 0 && nc < n && !used[nr][nc]) {
              neighbors.push([nr,nc]);
            }
          });
        });

        if (neighbors.length === 0) break;

        const [nr,nc] = neighbors[Math.floor(Math.random() * neighbors.length)];
        cage.cells.push([nr,nc]);
        used[nr][nc] = true;
        size++;
      }

      const values = cage.cells.map(([rr,cc]) => solution[rr][cc]);

      // Decide allowed operations based on cage size and difficulty rules
      let allowedOps;
      if (cage.cells.length === 1) {
        allowedOps = ["single"];
      } else if (cage.cells.length === 2) {
        // 2-cell cages can use any op allowed by difficulty
        allowedOps = ops.slice(); // copy
      } else {
        // 3- or 4-cell cages:
        // Gentle: will never reach here (maxSize = 2)
        // Moderate: only + or ×
        // Challenging: only + or ×
        allowedOps = ops.filter(o => o === "+" || o === "×");
        if (allowedOps.length === 0) {
          // Fallback safety: if somehow empty, default to +
          allowedOps = ["+"];
        }
      }

      const op = allowedOps[Math.floor(Math.random() * allowedOps.length)];

      let label;
      if (op === "single") {
        label = values[0];
      } else if (op === "+") {
        label = values.reduce((a,b)=>a+b) + "+";
      } else if (op === "×") {
        label = values.reduce((a,b)=>a*b) + "×";
      } else if (op === "-") {
        // By rule, this only occurs for 2-cell cages
        label = Math.abs(values[0] - values[1]) + "-";
      } else if (op === "÷") {
        // By rule, this only occurs for 2-cell cages
        const big = Math.max(...values);
        const small = Math.min(...values);
        label = (big / small) + "÷";
      }

      cage.label = label;
      cages.push(cage);
    }
  }

  return cages;
}

/* ---------------------------------------------------------
   APPLY CAGE BORDERS
   --------------------------------------------------------- */
function applyCageBorders(cages, cageMap) {
  const n = 6;
  const cells = document.querySelectorAll("#kenken td");

  function cellAt(r, c) {
    return cells[r * n + c];
  }

  for (let r = 0; r < n; r++) {
    for (let c = 0; c < n; c++) {
      const cell = cellAt(r, c);
      const cageId = cageMap[r][c].id;

      const up    = r > 0     && cageMap[r-1][c].id === cageId;
      const down  = r < n - 1 && cageMap[r+1][c].id === cageId;
      const left  = c > 0     && cageMap[r][c-1].id === cageId;
      const right = c < n - 1 && cageMap[r][c+1].id === cageId;

      if (!up)    cell.classList.add("cage-top");
      if (!down)  cell.classList.add("cage-bottom");
      if (!left)  cell.classList.add("cage-left");
      if (!right) cell.classList.add("cage-right");
    }
  }
}

/* ---------------------------------------------------------
   RENDER PUZZLE
   --------------------------------------------------------- */
function generatePuzzle() {
  const difficulty = document.getElementById("difficulty").value;
  const table = document.getElementById("kenken");
  table.innerHTML = "";

  const n = 6;
  const solution = generateLatinSquare(n);
  shuffleRows(solution);
  shuffleCols(solution);

  const cages = generateCages(solution, difficulty);

  const cageMap = Array.from({ length: n }, () => Array(n).fill(null));
  cages.forEach((cage, index) => {
    cage.cells.forEach(([r,c]) => {
      cageMap[r][c] = { id: index, label: cage.label };
    });
  });

  for (let r = 0; r < n; r++) {
    const row = document.createElement("tr");
    for (let c = 0; c < n; c++) {
      const cell = document.createElement("td");

      const labelDiv = document.createElement("div");
      labelDiv.className = "cage-label";

      const cage = cageMap[r][c];
      const isFirstCell =
        cages[cage.id].cells[0][0] === r &&
        cages[cage.id].cells[0][1] === c;

      if (isFirstCell) labelDiv.textContent = cage.label;

      cell.appendChild(labelDiv);

      const input = document.createElement("input");
      input.maxLength = 1;
      input.dataset.row = r;
      input.dataset.col = c;
      input.oninput = () => {
        input.value = input.value.replace(/[^1-6]/g, "");
      };
      cell.appendChild(input);

      row.appendChild(cell);
    }
    table.appendChild(row);
  }

  window.currentSolution = solution;

  applyCageBorders(cages, cageMap);
}

function checkKenKen() {
  const table = document.getElementById("kenken");
  const inputs = table.getElementsByTagName("input");
  const n = 6;
  let idx = 0;
  let complete = true;
  let correct = true;

  for (let r = 0; r < n; r++) {
    for (let c = 0; c < n; c++) {
      const input = inputs[idx++];
      const val = parseInt(input.value, 10);
      if (!val) {
        complete = false;
        continue;
      }
      if (val !== window.currentSolution[r][c]) {
        correct = false;
      }
    }
  }

  const msg = document.getElementById("message");
  if (!complete) {
    msg.textContent = "Some cells are still empty.";
    msg.style.color = "#cc7a00";
  } else if (correct) {
    msg.textContent = "Great job! You solved it.";
    msg.style.color = "#1f7a1f";
  } else {
    msg.textContent = "Not quite right yet — check cages, rows, and columns.";
    msg.style.color = "#b00020";
  }
}

/* Generate one puzzle on load */
generatePuzzle();
</script>

</body>
</html>
