<!DOCTYPE html>
<html lang="en">
<head>
  <meta charset="UTF-8" />
  <meta name="viewport" content="width=device-width, initial-scale=1.0" />
  <title>Pips • SullivanClan</title>

  <!-- Your fresh Pips Engine CSS goes here -->
  <style>
    /* ============================================================
       PIPS ENGINE — GLOBAL STYLESHEET
       Clean, modern, mobile‑first foundation for region puzzles
       ============================================================ */
    
    /* ------------------------------
       CSS VARIABLES (THEME)
       ------------------------------ */
    :root {
      --bg: #faf8f4;
      --grid-bg: #ffffff;
      --line: #333;
      --region-outline: #444;
      --region-fill: rgba(0, 0, 0, 0.04);
      --cell-size: 48px;
      --cell-gap: 2px;
      --radius: 6px;
    
      --domino-bg: #fff;
      --domino-border: #222;
      --domino-shadow: rgba(0, 0, 0, 0.15);
    
      --accent: #7a4c24; /* warm SullivanClan brown */
    }
    
    /* Mobile scaling */
    @media (max-width: 600px) {
      :root {
        --cell-size: 38px;
      }
    }
    
    /* ------------------------------
       PAGE LAYOUT
       ------------------------------ */
    body {
      margin: 0;
      padding: 0;
      background: var(--bg);
      font-family: system-ui, sans-serif;
      color: #222;
      display: flex;
      flex-direction: column;
      align-items: center;
    }
    
    /* Optional header bar */
    .pips-header {
      width: 100%;
      padding: 12px 20px;
      background: var(--accent);
      color: white;
      font-size: 1.2rem;
      font-weight: 600;
      text-align: center;
      letter-spacing: 0.5px;
    }
    
    /* ------------------------------
       GRID CONTAINER
       ------------------------------ */
    #pips-root {
      position: relative;
    }
    .pips-grid {
      display: grid;
      background: var(--grid-bg);
      padding: 10px;
      border-radius: var(--radius);
      box-shadow: 0 2px 6px rgba(0,0,0,0.1);
      gap: var(--cell-gap);
      position: relative;
      margin-top: 20px;
    }
    
    /* The JS will set grid-template-columns dynamically */
    .pips-cell {
      width: var(--cell-size);
      height: var(--cell-size);
      background: white;
      border: 1px solid var(--line);
      border-radius: 4px;
      position: relative;
      box-sizing: border-box;
    }
    
    /* ------------------------------
       REGION OUTLINES
       ------------------------------ */
    
    /* Base region class — JS will add region-A, region-B, etc. */
    .region {
      position: absolute;
      border: 2px solid var(--region-outline);
      background: var(--region-fill);
      border-radius: var(--radius);
      pointer-events: none; /* regions never block dominos */
      box-sizing: border-box;
    }
    
    /* Optional region labels */
    .region-label {
      position: absolute;
      top: -14px;
      left: 4px;
      background: var(--accent);
      color: white;
      padding: 2px 6px;
      font-size: 0.7rem;
      border-radius: 4px;
      pointer-events: none;
    }
    
    /* ------------------------------
       DOMINO TRAY + TILES
       ------------------------------ */
    .tray-slot {
      width: 50px;      /* match domino width */
      height: 100px;    /* match domino height */
      position: relative;
      border: 1px solid transparent; /* invisible placeholder */
      display: flex;
      align-items: center;
      justify-content: center;
    }
    
    .tray-slot .domino {
      position: relative; /* domino sits normally inside the slot */
    }
    .domino-tray {
      margin-top: 24px;
      display: flex;
      flex-wrap: wrap;
      gap: 10px;
      justify-content: center;
    }
    
    /* ============================================================
       DOMINO TILE — COMPLETE BLOCK
       ============================================================ */
    .domino {
      position: relative;
      width: calc(var(--cell-size) * 2 + var(--cell-gap));
      height: var(--cell-size);
      background: var(--domino-bg);
      border: 2px solid var(--domino-border);
      border-radius: var(--radius);
      box-shadow: 0 2px 4px var(--domino-shadow);
      cursor: grab;
      user-select: none;
      transition: transform 0.15s ease;
      display: grid;
      grid-template-columns: 1fr 1fr;
      place-items: center;   /* centers pip-groups in each half */
      box-sizing: border-box;
    }

    .domino.vertical {
      width: var(--cell-size);
      height: calc(var(--cell-size) * 2 + var(--cell-gap));
      flex-direction: column;
      justify-content: space-between;
      padding-top: 8px;
      padding-bottom: 8px;
      box-sizing: border-box;   /* <-- SAME FIX HERE */
    }
  
    /* Center dividing line */
    .domino::after {
      content: "";
      position: absolute;
      background: var(--domino-border);
      opacity: 0.8;
    }
    
    .domino:not(.vertical)::after {
      width: 2px;
      height: 80%;
      left: 50%;
      top: 10%;
      transform: translateX(-1px);
    }
    
    .domino.vertical::after {
      height: 2px;
      width: 80%;
      top: 50%;
      left: 10%;
      transform: translateY(-1px);
    }

    /* Hard-sized pip cluster box — always centered, never expands */
    .pip-group {
      width: 28px;
      height: 28px;
      margin: auto;        /* centers horizontally AND vertically */
      display: grid;
      grid-template-columns: repeat(3, 1fr);
      grid-template-rows: repeat(3, 1fr);
      place-items: center;
    }

    /* Small, tight pips */
    .pip {
      width: 8px;
      height: 8px;
      background: var(--line);
      border-radius: 50%;
    }
    
    /* ------------------------------
       PLACEMENT STATES
       ------------------------------ */
    .cell-highlight {
      outline: 3px solid var(--accent);
      outline-offset: -3px;
    }
    
    .cell-invalid {
      background: #f8d0d0;
      border-color: #b33;
    }
    
    /* When a domino is snapped into place */
    .domino-placed {
      box-shadow: none;
      cursor: default;
      opacity: 0.95;
    }
    
    /* ------------------------------
       UTILITY CLASSES
       ------------------------------ */
    .hidden {
      display: none !important;
    }
    
    .center {
      display: flex;
      justify-content: center;
      align-items: center;
    }
  </style>
</head>

<body>

  <!-- Header Bar -->
  <div class="pips-header">
    Pips Puzzle Engine
  </div>

  <div id="pips-root">
  
    <!-- Grid Wrapper -->
    <div id="pips-wrapper" class="center">
  
      <!-- Region overlay layer (absolute positioned) -->
      <div id="region-layer"></div>
  
      <!-- The puzzle grid (JS will size it dynamically) -->
      <div id="pips-grid" class="pips-grid"></div>
  
    </div>
  
    <!-- Domino Tray -->
      <div id="domino-tray">
      <div class="tray-slot" id="slot-0"></div>
      <div class="tray-slot" id="slot-1"></div>
      <div class="tray-slot" id="slot-2"></div>
      <div class="tray-slot" id="slot-3"></div>
      <div class="tray-slot" id="slot-4"></div>
      <div class="tray-slot" id="slot-5"></div>
      <div class="tray-slot" id="slot-6"></div>
      <div class="tray-slot" id="slot-7"></div>
      <div class="tray-slot" id="slot-8"></div>
      <div class="tray-slot" id="slot-9"></div>
      <div class="tray-slot" id="slot-10"></div>
      <div class="tray-slot" id="slot-11"></div>
      <div class="tray-slot" id="slot-12"></div>
      <div class="tray-slot" id="slot-13"></div>
      <div class="tray-slot" id="slot-14"></div>
      <div class="tray-slot" id="slot-15"></div>
      <div class="tray-slot" id="slot-16"></div>
      <div class="tray-slot" id="slot-17"></div>
      <div class="tray-slot" id="slot-18"></div>
      <div class="tray-slot" id="slot-19"></div>
      <div class="tray-slot" id="slot-20"></div>
      <div class="tray-slot" id="slot-21"></div>
      <div class="tray-slot" id="slot-22"></div>
      <div class="tray-slot" id="slot-23"></div>
      <div class="tray-slot" id="slot-24"></div>
      <div class="tray-slot" id="slot-25"></div>
      <div class="tray-slot" id="slot-26"></div>
      <div class="tray-slot" id="slot-27"></div>
    </div>

  </div>

  <!-- JS Engine (you will paste your logic here) -->
  <script>
    // Example placeholder to show where your engine will go
    // -----------------------------------------------------

    // 1. Initialize grid
    // 2. Draw regions
    // 3. Create dominos
    // 4. Handle drag/drop + placement logic

    console.log("Pips Engine ready for JS...");


   
    /* ============================================================
       PIPS ENGINE — GRID BUILDER
       Creates the puzzle grid dynamically
       ============================================================ */
    
    function buildGrid(rows, cols) {
      const grid = document.getElementById("pips-grid");
      grid.innerHTML = ""; // clear any previous puzzle
    
      // Set CSS grid columns
      grid.style.gridTemplateColumns = `repeat(${cols}, var(--cell-size))`;
    
      // Create cells
      for (let r = 0; r < rows; r++) {
        for (let c = 0; c < cols; c++) {
          const cell = document.createElement("div");
          cell.classList.add("pips-cell");
          cell.dataset.row = r;
          cell.dataset.col = c;
          cell.id = `cell-${r}-${c}`;
          grid.appendChild(cell);
        }
      }
    
      console.log(`Grid built: ${rows} × ${cols}`);
    }
    
    let activeDomino = null;
    let offsetX = 0;
    let offsetY = 0;

    const standardDominos = [
        [0,0], [0,1], [0,2], [0,3], [0,4], [0,5], [0,6],
        [1,1], [1,2], [1,3], [1,4], [1,5], [1,6],
        [2,2], [2,3], [2,4], [2,5], [2,6],
        [3,3], [3,4], [3,5], [3,6],
        [4,4], [4,5], [4,6],
        [5,5], [5,6],
        [6,6]
      ];

    /* ============================================================
       INITIALIZE A TEST GRID
       (You can change this to any puzzle size)
       ============================================================ */
    
      document.addEventListener("DOMContentLoaded", () => {
        buildGrid(6, 6);
        drawRegions([]); // optional for now
        buildDominoTray(standardDominos);
        enableDominoInteractions();
      });


// 2
      /* ============================================================
         PIPS ENGINE — REGION RENDERER
         Draws region shapes as overlays on top of the grid
         ============================================================ */
      
      function drawRegions(regionList) {
        const regionLayer = document.getElementById("region-layer");
        regionLayer.innerHTML = ""; // clear previous regions
      
        regionList.forEach((region, index) => {
          const regionDiv = document.createElement("div");
          regionDiv.classList.add("region");
      
          // Compute bounding box of the region
          const rows = region.map(c => c[0]);
          const cols = region.map(c => c[1]);
      
          const minRow = Math.min(...rows);
          const maxRow = Math.max(...rows);
          const minCol = Math.min(...cols);
          const maxCol = Math.max(...cols);
      
          // Convert grid coordinates to pixel positions
          const cellSize = parseInt(getComputedStyle(document.documentElement).getPropertyValue("--cell-size"));
          const cellGap = parseInt(getComputedStyle(document.documentElement).getPropertyValue("--cell-gap"));
      
          const x = minCol * (cellSize + cellGap);
          const y = minRow * (cellSize + cellGap);
          const width = (maxCol - minCol + 1) * (cellSize + cellGap) - cellGap;
          const height = (maxRow - minRow + 1) * (cellSize + cellGap) - cellGap;
      
          // Position the region overlay
          regionDiv.style.left = `${x}px`;
          regionDiv.style.top = `${y}px`;
          regionDiv.style.width = `${width}px`;
          regionDiv.style.height = `${height}px`;
      
          // Optional label
          const label = document.createElement("div");
          label.classList.add("region-label");
          label.textContent = String.fromCharCode(65 + index); // A, B, C...
          regionDiv.appendChild(label);
      
          regionLayer.appendChild(regionDiv);
        });
      
        console.log("Regions drawn:", regionList.length);
      }


// 3
      /* ============================================================
         PIPS ENGINE — DOMINO GENERATOR (FINAL VERSION)
         Creates domino tiles, then assigns each one a fixed home slot
         ============================================================ */
      
      function buildDominoTray(dominoList) {
        const tray = document.getElementById("domino-tray");
        tray.innerHTML = ""; // clear previous puzzle
      
        // --- STEP A: Create all domino elements ---
        dominoList.forEach((pair, index) => {
          const [a, b] = pair;
      
          const domino = document.createElement("div");
          domino.classList.add("domino");
          domino.dataset.index = index;
          domino.dataset.valueA = a;
          domino.dataset.valueB = b;
      
          // Pip groups
          const pipA = createPipGroup(a);
          const pipB = createPipGroup(b);
      
          domino.appendChild(pipA);
          domino.appendChild(pipB);
      
          // Rotation support
          domino.addEventListener("dblclick", () => {
            domino.classList.toggle("vertical");
          });
      
          // Temporarily append to tray (we will move it into slots next)
          tray.appendChild(domino);
        });
      
        console.log("Domino tray built:", dominoList.length);
      
        // --- STEP B: Assign each domino a fixed home slot ---
        const traySlots = document.querySelectorAll(".tray-slot");
        const trayDominoes = tray.querySelectorAll(".domino");
      
        trayDominoes.forEach((domino, i) => {
          const slot = traySlots[i];
          domino.dataset.homeSlot = slot.id;   // remember home slot
          slot.appendChild(domino);            // move domino into its slot
        });
      }
     
      /* ============================================================
         PIP RENDERING
         Creates a group of pips for a single number (0–6)
         ============================================================ */
      function createPipGroup(value) {
        const group = document.createElement("div");
        group.classList.add("pip-group");
      
        // Pip layout patterns for 0–6
         const pipPatterns = {
          0: [],
          1: [ [1,1] ],
          2: [ [0,0], [2,2] ],
          3: [ [0,0], [1,1], [2,2] ],
          4: [ [0,0], [0,2], [2,0], [2,2] ],
          5: [ [0,0], [0,2], [1,1], [2,0], [2,2] ],
          6: [ [0,0], [0,1], [0,2],   // top row
               [2,0], [2,1], [2,2]    // bottom row
          ]
        };
     
        const pattern = pipPatterns[value] || [];
      
        // Create a 3×3 pip grid
        group.style.display = "grid";
        group.style.gridTemplateColumns = "repeat(3, 1fr)";
        group.style.gridTemplateRows = "repeat(3, 1fr)";

        pattern.forEach(([r, c]) => {
          const pip = document.createElement("div");
          pip.classList.add("pip");
          pip.style.gridRow = r + 1;
          pip.style.gridColumn = c + 1;
          group.appendChild(pip);
        });
      
        return group;
      }

      const traySlots = document.querySelectorAll(".tray-slot");
      
      dominoes.forEach((domino, i) => {
        const slot = traySlots[i];
        domino.dataset.homeSlot = slot.id;   // remember home slot
        slot.appendChild(domino);            // place domino in that slot
      });

    
  // 4
      /* ============================================================
         PIPS ENGINE — DRAG & DROP + PLACEMENT LOGIC
         ============================================================ */
      function enableDominoInteractions() {
        const tray = document.getElementById("domino-tray");
      
        tray.querySelectorAll(".domino").forEach(domino => {
          domino.addEventListener("mousedown", startDrag);
          domino.addEventListener("touchstart", startDrag, { passive: false });
        });
      
        document.addEventListener("mousemove", drag);
        document.addEventListener("touchmove", drag, { passive: false });
      
        document.addEventListener("mouseup", endDrag);
        document.addEventListener("touchend", endDrag);
      }
      
      /* ------------------------------
         START DRAG
         ------------------------------ */
      function startDrag(e) {
        e.preventDefault();
      
        activeDomino = e.currentTarget;
      
        // Record whether the domino came from the tray or the board
        const parent = activeDomino.parentElement;
        if (parent.classList.contains("tray-slot")) {
          activeDomino.dataset.origin = "tray";
        } else {
          activeDomino.dataset.origin = "board";
        }
      
        const clientX = e.touches ? e.touches[0].clientX : e.clientX;
        const clientY = e.touches ? e.touches[0].clientY : e.clientY;
      
        // Measure BEFORE append
        const preRect = activeDomino.getBoundingClientRect();
        offsetX = clientX - preRect.left;
        offsetY = clientY - preRect.top;
      
        const root = document.getElementById("pips-root");
        const rootRect = root.getBoundingClientRect();
      
        // Move into root
        root.appendChild(activeDomino);
      
        // Position the domino under the cursor
        activeDomino.style.position = "absolute";
        activeDomino.style.zIndex = 1000;
        activeDomino.style.left = `${clientX - offsetX - rootRect.left}px`;
        activeDomino.style.top  = `${clientY - offsetY - rootRect.top}px`;
      
        highlightPossibleCells(activeDomino);
      }

      /* ------------------------------
         DRAG MOVEMENT
         ------------------------------ */
      function drag(e) {
console.log("USING CORRECT DRAG");
        if (!activeDomino) return;
      
        const clientX = e.touches ? e.touches[0].clientX : e.clientX;
        const clientY = e.touches ? e.touches[0].clientY : e.clientY;
      
        const rootRect = document.getElementById("pips-root").getBoundingClientRect();
      
        activeDomino.style.left = `${clientX - offsetX - rootRect.left}px`;
        activeDomino.style.top  = `${clientY - offsetY - rootRect.top}px`;
      }

      /* ------------------------------
         END DRAG → TRY TO PLACE
         ------------------------------ */
      function endDrag() {
        if (!activeDomino) return;
      
        // Try to place the domino on the board
        const snapped = tryPlaceDomino(activeDomino);
      
        clearHighlights();
      
        if (!snapped) {
          // Not placed on the board → return to home slot
          const home = document.getElementById(activeDomino.dataset.homeSlot);
          home.appendChild(activeDomino);
      
          // Reset styling so it flows normally in the tray slot
          activeDomino.style.position = "";
          activeDomino.style.left = "";
          activeDomino.style.top = "";
          activeDomino.style.zIndex = "";
        }
      
        activeDomino = null;
      }
  
     /* ============================================================
         PLACEMENT LOGIC
         ============================================================ */
      function tryPlaceDomino(domino) {
      
        // === DIAGNOSTICS ===
        console.log("=== DIAGNOSTIC START ===");
      
        const diagRoot = document.getElementById("pips-root");
        const diagGrid = document.getElementById("pips-grid");
      
        const diagRootRect = diagRoot.getBoundingClientRect();
        const diagGridRect = diagGrid.getBoundingClientRect();
        const diagDomRaw = domino.getBoundingClientRect();
      
        console.log("rootRect.left:", diagRootRect.left);
        console.log("gridRect.left:", diagGridRect.left);
        console.log("domRaw.left:", diagDomRaw.left);
      
        console.log("domRaw.left - rootRect.left:", diagDomRaw.left - diagRootRect.left);
        console.log("domRaw.left - gridRect.left:", diagDomRaw.left - diagGridRect.left);
      
        console.log("=== DIAGNOSTIC END ===");
      
        // === NORMALIZED DOMINO RECT ===
        const rootRect = document.getElementById("pips-root").getBoundingClientRect();
        const rawDom = domino.getBoundingClientRect();
        const domRect = {
          left:   rawDom.left   - rootRect.left,
          right:  rawDom.right  - rootRect.left,
          top:    rawDom.top    - rootRect.top,
          bottom: rawDom.bottom - rootRect.top,
          width:  rawDom.width,
          height: rawDom.height
        };
      
        console.log("DOMINO width:", domRect.width);
      
        // === LEFT HALF OF DOMINO ===
        const leftHalf = {
          left: domRect.left,
          right: domRect.left + domRect.width / 2,
          top: domRect.top,
          bottom: domRect.bottom
        };
      
        // === FIND BEST CELL(S) BASED ON LEFT HALF OVERLAP ===
        let bestCells = [];
        let bestOverlap = 0;
      
        document.querySelectorAll(".pips-cell").forEach(cell => {
      
          const raw = cell.getBoundingClientRect();
          const rect = {
            left:   raw.left   - rootRect.left,
            right:  raw.right  - rootRect.left,
            top:    raw.top    - rootRect.top,
            bottom: raw.bottom - rootRect.top
          };
      
          // Log width of cell 0,0 for diagnostics
          if (cell.dataset.row === "0" && cell.dataset.col === "0") {
            console.log("CELL width:", rect.right - rect.left);
          }
      
          // Overlap with LEFT HALF ONLY
          const overlapLeft   = Math.max(leftHalf.left, rect.left);
          const overlapRight  = Math.min(leftHalf.right, rect.right);
          const overlapTop    = Math.max(leftHalf.top, rect.top);
          const overlapBottom = Math.min(leftHalf.bottom, rect.bottom);
      
          const overlapWidth  = overlapRight - overlapLeft;
          const overlapHeight = overlapBottom - overlapTop;
      
          if (overlapWidth > 0 && overlapHeight > 0) {
            const overlapArea = overlapWidth * overlapHeight;
      
            console.log(
              "cell", cell.dataset.row, cell.dataset.col,
              "overlap:", overlapArea
            );
      
            if (overlapArea > bestOverlap) {
              bestOverlap = overlapArea;
              bestCells = [cell];
            } else if (Math.abs(overlapArea - bestOverlap) < 0.001) {
              // Tie — add this cell as equally valid
              bestCells.push(cell);
            }
          }
        });
      
        // === NO OVERLAP AT ALL → OFF THE BOARD ===
        if (bestCells.length === 0) {
          flashInvalid(domino);
          return false;
        }
      
        // === 25% MINIMUM OVERLAP RULE ===
        const cellRect = bestCells[0].getBoundingClientRect();
        const minArea = (cellRect.width * cellRect.height) * 0.25;
      
        if (bestOverlap < minArea) {
          flashInvalid(domino);
          return false;
        }
      
        // === PICK ANY OF THE TIED CELLS ===
        const bestCell = bestCells[0];
      
        const row = parseInt(bestCell.dataset.row, 10);
        const col = parseInt(bestCell.dataset.col, 10);
      
        const vertical = domino.classList.contains("vertical");
      
        const cells = vertical
          ? [ [row, col], [row + 1, col] ]
          : [ [row, col], [row, col + 1] ];
      
        // === VALIDATE BOTH CELLS EXIST ===
        if (!cells.every(([r, c]) => document.getElementById(`cell-${r}-${c}`))) {
          flashInvalid(domino);
          return false;
        }
      
        // === SNAP DOMINO TO BEST CELL ===
        const targetRect = bestCell.getBoundingClientRect();
      
        domino.style.left = `${targetRect.left - rootRect.left}px`;
        domino.style.top  = `${targetRect.top  - rootRect.top}px`;
        domino.classList.add("domino-placed");
      
        return true;
      }

      /* ------------------------------
         VALIDATION HELPERS
         ------------------------------ */
      function isValidCell(r, c) {
        const cell = document.getElementById(`cell-${r}-${c}`);
        return cell !== null;
      }
      
      function flashInvalid(domino) {
        domino.classList.add("cell-invalid");
        setTimeout(() => domino.classList.remove("cell-invalid"), 300);
      }
      
      /* ============================================================
         HIGHLIGHTING
         ============================================================ */
      
      function highlightPossibleCells(domino) {
        const grid = document.getElementById("pips-grid");
        const cells = grid.querySelectorAll(".pips-cell");
      
        cells.forEach(cell => cell.classList.add("cell-highlight"));
      }
      
      function clearHighlights() {
        document.querySelectorAll(".cell-highlight").forEach(c =>
          c.classList.remove("cell-highlight")
        );
      }

   
   
  </script>

</body>
</html>
