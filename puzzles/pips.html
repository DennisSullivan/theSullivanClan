<!DOCTYPE html>
<html lang="en">
<head>
  <meta charset="UTF-8" />
  <meta name="viewport" content="width=device-width, initial-scale=1.0" />
  <title>Pips • SullivanClan</title>

  <!-- Your fresh Pips Engine CSS goes here -->
  <style>
    /* ============================================================
       PIPS ENGINE — GLOBAL STYLESHEET
       Clean, modern, mobile‑first foundation for region puzzles
       ============================================================ */
    
    /* ------------------------------
       CSS VARIABLES (THEME)
       ------------------------------ */
    :root {
      --bg: #faf8f4;
      --grid-bg: #ffffff;
      --line: #333;
      --region-outline: #444;
      --region-fill: rgba(0, 0, 0, 0.04);
      --cell-size: 48px;
      --cell-gap: 2px;
      --radius: 6px;
    
      --domino-bg: #fff;
      --domino-border: #222;
      --domino-shadow: rgba(0, 0, 0, 0.15);
    
      --accent: #7a4c24; /* warm SullivanClan brown */
    }
    
    /* Mobile scaling */
    @media (max-width: 600px) {
      :root {
        --cell-size: 38px;
      }
    }
    
    /* ------------------------------
       PAGE LAYOUT
       ------------------------------ */
    body {
      margin: 0;
      padding: 0;
      background: var(--bg);
      font-family: system-ui, sans-serif;
      color: #222;
      display: flex;
      flex-direction: column;
      align-items: center;
    }
    
    /* Optional header bar */
    .pips-header {
      width: 100%;
      padding: 12px 20px;
      background: var(--accent);
      color: white;
      font-size: 1.2rem;
      font-weight: 600;
      text-align: center;
      letter-spacing: 0.5px;
    }
    
    /* ------------------------------
       GRID CONTAINER
       ------------------------------ */
    #pips-root {
      position: relative;
    }
    .pips-grid {
      display: grid;
      background: var(--grid-bg);
      padding: 10px;
      border-radius: var(--radius);
      box-shadow: 0 2px 6px rgba(0,0,0,0.1);
      gap: var(--cell-gap);
      position: relative;
      margin-top: 20px;
    }
    
    /* The JS will set grid-template-columns dynamically */
    .pips-cell {
      width: var(--cell-size);
      height: var(--cell-size);
      background: white;
      border: 1px solid var(--line);
      border-radius: 4px;
      position: relative;
      box-sizing: border-box;
    }
    
    /* ------------------------------
       REGION OUTLINES
       ------------------------------ */
    
    /* Base region class — JS will add region-A, region-B, etc. */
    .region {
      position: absolute;
      border: 2px solid var(--region-outline);
      background: var(--region-fill);
      border-radius: var(--radius);
      pointer-events: none; /* regions never block dominos */
      box-sizing: border-box;
    }
    
    /* Optional region labels */
    .region-label {
      position: absolute;
      top: -14px;
      left: 4px;
      background: var(--accent);
      color: white;
      padding: 2px 6px;
      font-size: 0.7rem;
      border-radius: 4px;
      pointer-events: none;
    }
    
    /* ------------------------------
       DOMINO TRAY + TILES
       ------------------------------ */
    .tray-slot {
      width: calc(var(--cell-size) * 2 + var(--cell-gap));
      height: var(--cell-size);
      position: relative;
      border: 1px solid transparent; /* invisible placeholder */
      display: flex;
      align-items: center;
      justify-content: center;
    }
    
    .tray-slot .domino {
      position: relative; /* domino sits normally inside the slot */
    }
    .domino-tray {
      margin-top: 24px;
      display: flex;
      flex-wrap: wrap;
      gap: 10px;
      justify-content: center;
    }
    
    /* ============================================================
       DOMINO TILE — COMPLETE BLOCK
       ============================================================ */
    .domino {
      position: relative;
      width: calc(var(--cell-size) * 2 + var(--cell-gap));
      height: var(--cell-size);
      background: var(--domino-bg);
      border: 2px solid var(--domino-border);
      border-radius: var(--radius);
      box-shadow: 0 2px 4px var(--domino-shadow);
      cursor: grab;
      user-select: none;
      transition: transform 0.15s ease;
      display: grid;
      grid-template-columns: 1fr 1fr;
      place-items: center;   /* centers pip-groups in each half */
      box-sizing: border-box;
    }

    .domino.vertical {
      width: var(--cell-size);
      height: calc(var(--cell-size) * 2 + var(--cell-gap));
      flex-direction: column;
      justify-content: space-between;
      padding-top: 8px;
      padding-bottom: 8px;
      box-sizing: border-box;   /* <-- SAME FIX HERE */
    }
  
    /* Center dividing line */
    .domino::after {
      content: "";
      position: absolute;
      background: var(--domino-border);
      opacity: 0.8;
    }
    
    .domino:not(.vertical)::after {
      width: 2px;
      height: 80%;
      left: 50%;
      top: 10%;
      transform: translateX(-1px);
    }
    
    .domino.vertical::after {
      height: 2px;
      width: 80%;
      top: 50%;
      left: 10%;
      transform: translateY(-1px);
    }

    /* Hard-sized pip cluster box — always centered, never expands */
    .pip-group {
      width: 28px;
      height: 28px;
      margin: auto;        /* centers horizontally AND vertically */
      display: grid;
      grid-template-columns: repeat(3, 1fr);
      grid-template-rows: repeat(3, 1fr);
      place-items: center;
    }

    /* Small, tight pips */
    .pip {
      width: 8px;
      height: 8px;
      background: var(--line);
      border-radius: 50%;
    }
    
    /* ------------------------------
       PLACEMENT STATES
       ------------------------------ */
    .cell-highlight {
      outline: 3px solid var(--accent);
      outline-offset: -3px;
    }
    
    .cell-invalid {
      background: #f8d0d0;
      border-color: #b33;
    }
    
    /* When a domino is snapped into place */
    .domino-placed {
      box-shadow: none;
      cursor: default;
      opacity: 0.95;
    }
    
    /* ------------------------------
       UTILITY CLASSES
       ------------------------------ */
    .hidden {
      display: none !important;
    }
    
    .center {
      display: flex;
      justify-content: center;
      align-items: center;
    }
  </style>
</head>

<body>

  <!-- Header Bar -->
  <div class="pips-header">
    Pips Puzzle Engine
  </div>

  <div id="pips-root">
  
    <!-- Grid Wrapper -->
    <div id="pips-wrapper" class="center">
  
      <!-- Region overlay layer (absolute positioned) -->
      <div id="region-layer"></div>
  
      <!-- The puzzle grid (JS will size it dynamically) -->
      <div id="pips-grid" class="pips-grid"></div>
  
    </div>
  
    <!-- Domino Tray -->
      <div id="domino-tray" class="domino-tray">
      <div class="tray-slot" id="slot-0"></div>
      <div class="tray-slot" id="slot-1"></div>
      <div class="tray-slot" id="slot-2"></div>
      <div class="tray-slot" id="slot-3"></div>
      <div class="tray-slot" id="slot-4"></div>
      <div class="tray-slot" id="slot-5"></div>
      <div class="tray-slot" id="slot-6"></div>
      <div class="tray-slot" id="slot-7"></div>
      <div class="tray-slot" id="slot-8"></div>
      <div class="tray-slot" id="slot-9"></div>
      <div class="tray-slot" id="slot-10"></div>
      <div class="tray-slot" id="slot-11"></div>
      <div class="tray-slot" id="slot-12"></div>
      <div class="tray-slot" id="slot-13"></div>
      <div class="tray-slot" id="slot-14"></div>
      <div class="tray-slot" id="slot-15"></div>
      <div class="tray-slot" id="slot-16"></div>
      <div class="tray-slot" id="slot-17"></div>
      <div class="tray-slot" id="slot-18"></div>
      <div class="tray-slot" id="slot-19"></div>
      <div class="tray-slot" id="slot-20"></div>
      <div class="tray-slot" id="slot-21"></div>
      <div class="tray-slot" id="slot-22"></div>
      <div class="tray-slot" id="slot-23"></div>
      <div class="tray-slot" id="slot-24"></div>
      <div class="tray-slot" id="slot-25"></div>
      <div class="tray-slot" id="slot-26"></div>
      <div class="tray-slot" id="slot-27"></div>
    </div>

  </div>

  <!-- JS Engine (you will paste your logic here) -->
  <script>
    // Board occupancy: key "r,c" -> domino element
    const boardOccupancy = {};

function logBoardOccupancy() {
  console.log("=== BOARD OCCUPANCY ===");
  const entries = Object.entries(boardOccupancy);
  if (entries.length === 0) {
    console.log("  (empty)");
  } else {
    entries.forEach(([key, value]) => {
      const label = value.id ? value.id : "(no id)";
      console.log(`  cell ${key} -> domino ${label}`);
    });
  }
  console.log("========================");
}


    /* ============================================================
       PIPS ENGINE — GRID BUILDER
       Creates the puzzle grid dynamically
       ============================================================ */
    
    function buildGrid(rows, cols) {
      const grid = document.getElementById("pips-grid");
      grid.innerHTML = ""; // clear any previous puzzle
    
      // Set CSS grid columns
      grid.style.gridTemplateColumns = `repeat(${cols}, var(--cell-size))`;
    
      // Create cells
      for (let r = 0; r < rows; r++) {
        for (let c = 0; c < cols; c++) {
          const cell = document.createElement("div");
          cell.classList.add("pips-cell");
          cell.dataset.row = r;
          cell.dataset.col = c;
          cell.id = `cell-${r}-${c}`;
          grid.appendChild(cell);
        }
      }
    
    }
    
    let activeDomino = null;
    let offsetX = 0;
    let offsetY = 0;

    const standardDominos = [
        [0,0], [0,1], [0,2], [0,3], [0,4], [0,5], [0,6],
        [1,1], [1,2], [1,3], [1,4], [1,5], [1,6],
        [2,2], [2,3], [2,4], [2,5], [2,6],
        [3,3], [3,4], [3,5], [3,6],
        [4,4], [4,5], [4,6],
        [5,5], [5,6],
        [6,6]
      ];

    /* ============================================================
       INITIALIZE A TEST GRID
       (You can change this to any puzzle size)
       ============================================================ */
    
      document.addEventListener("DOMContentLoaded", () => {
        buildGrid(6, 6);
        drawRegions([]); // optional for now
        buildDominoTray(standardDominos);
        enableDominoInteractions();
      });


// 2
      /* ============================================================
         PIPS ENGINE — REGION RENDERER
         Draws region shapes as overlays on top of the grid
         ============================================================ */
      
      function drawRegions(regionList) {
        const regionLayer = document.getElementById("region-layer");
        regionLayer.innerHTML = ""; // clear previous regions
      
        regionList.forEach((region, index) => {
          const regionDiv = document.createElement("div");
          regionDiv.classList.add("region");
      
          // Compute bounding box of the region
          const rows = region.map(c => c[0]);
          const cols = region.map(c => c[1]);
      
          const minRow = Math.min(...rows);
          const maxRow = Math.max(...rows);
          const minCol = Math.min(...cols);
          const maxCol = Math.max(...cols);
      
          // Convert grid coordinates to pixel positions
          const cellSize = parseInt(getComputedStyle(document.documentElement).getPropertyValue("--cell-size"));
          const cellGap = parseInt(getComputedStyle(document.documentElement).getPropertyValue("--cell-gap"));
      
          const x = minCol * (cellSize + cellGap);
          const y = minRow * (cellSize + cellGap);
          const width = (maxCol - minCol + 1) * (cellSize + cellGap) - cellGap;
          const height = (maxRow - minRow + 1) * (cellSize + cellGap) - cellGap;
      
          // Position the region overlay
          regionDiv.style.left = `${x}px`;
          regionDiv.style.top = `${y}px`;
          regionDiv.style.width = `${width}px`;
          regionDiv.style.height = `${height}px`;
      
          // Optional label
          const label = document.createElement("div");
          label.classList.add("region-label");
          label.textContent = String.fromCharCode(65 + index); // A, B, C...
          regionDiv.appendChild(label);
      
          regionLayer.appendChild(regionDiv);
        });
      
        console.log("Regions drawn:", regionList.length);
      }


// 3
      /* ============================================================
         PIPS ENGINE — DOMINO GENERATOR (FINAL VERSION)
         Creates domino tiles, then assigns each one a fixed home slot
         ============================================================ */
      function buildDominoTray(dominoList) {
        const tray = document.getElementById("domino-tray");
      
        // ------------------------------------------------------------
        // STEP 0 — KEEP the tray slots, but clear any old dominoes
        // ------------------------------------------------------------
        const traySlots = tray.querySelectorAll(".tray-slot");
        traySlots.forEach(slot => {
          slot.innerHTML = "";   // remove any domino previously inside
        });
      
        // ------------------------------------------------------------
        // STEP 1 — Create all domino elements (not attached yet)
        // ------------------------------------------------------------
        const newDominoes = [];
      
        dominoList.forEach((pair, index) => {
          const [a, b] = pair;
      
          const domino = document.createElement("div");
          domino.classList.add("domino");
          domino.dataset.index = index;
          domino.dataset.valueA = a;
          domino.dataset.valueB = b;
      
          const pipA = createPipGroup(a);
          const pipB = createPipGroup(b);
      
          domino.appendChild(pipA);
          domino.appendChild(pipB);
      
          domino.addEventListener("dblclick", () => {
            domino.classList.toggle("vertical");
          });
      
          newDominoes.push(domino);
        });
      
        console.log("Domino tray built:", newDominoes.length);
      
        // ------------------------------------------------------------
        // STEP 2 — Assign each domino to its matching tray slot
        // ------------------------------------------------------------
        console.log("SLOTS:", traySlots.length, "DOMINOES:", newDominoes.length);
      
        newDominoes.forEach((domino, i) => {
          const slot = traySlots[i];
      
          if (!slot) {
            console.warn("No tray slot for domino index", i, domino);
            return;
          }
      
          domino.dataset.homeSlot = slot.id;
          slot.appendChild(domino);
        });
      }

    /* ============================================================
         PIP RENDERING
         Creates a group of pips for a single number (0–6)
         ============================================================ */
      function createPipGroup(value) {
        const group = document.createElement("div");
        group.classList.add("pip-group");
      
        // Pip layout patterns for 0–6
         const pipPatterns = {
          0: [],
          1: [ [1,1] ],
          2: [ [0,0], [2,2] ],
          3: [ [0,0], [1,1], [2,2] ],
          4: [ [0,0], [0,2], [2,0], [2,2] ],
          5: [ [0,0], [0,2], [1,1], [2,0], [2,2] ],
          6: [ [0,0], [0,1], [0,2],   // top row
               [2,0], [2,1], [2,2]    // bottom row
          ]
        };
     
        const pattern = pipPatterns[value] || [];
      
        // Create a 3×3 pip grid
        group.style.display = "grid";
        group.style.gridTemplateColumns = "repeat(3, 1fr)";
        group.style.gridTemplateRows = "repeat(3, 1fr)";

        pattern.forEach(([r, c]) => {
          const pip = document.createElement("div");
          pip.classList.add("pip");
          pip.style.gridRow = r + 1;
          pip.style.gridColumn = c + 1;
          group.appendChild(pip);
        });
      
        return group;
      }

    
  // 4
      /* ============================================================
         PIPS ENGINE — DRAG & DROP + PLACEMENT LOGIC
         ============================================================ */
      function enableDominoInteractions() {
        document.querySelectorAll(".domino").forEach(domino => {
          domino.addEventListener("mousedown", startDrag);
          domino.addEventListener("touchstart", startDrag, { passive: false });
        });
      
        document.addEventListener("mousemove", drag);
        document.addEventListener("touchmove", drag, { passive: false });
      
        document.addEventListener("mouseup", endDrag);
        document.addEventListener("touchend", endDrag);
      }
      
      /* ------------------------------
         START DRAG
         ------------------------------ */
      function startDrag(e) {
        e.preventDefault();
      
        activeDomino = e.currentTarget;
      
        const parent = activeDomino.parentElement;
        const cameFromBoard = parent.classList.contains("pips-cell") || parent.id === "pips-root";
      
        // Track origin
        activeDomino.dataset.origin = cameFromBoard ? "board" : "tray";
      
        // Save previous board position if it came from the board
        if (activeDomino.dataset.origin === "board") {
          activeDomino.dataset.prevRow = activeDomino.dataset.boardRow || "";
          activeDomino.dataset.prevCol = activeDomino.dataset.boardCol || "";
          activeDomino.dataset.prevOrientation = activeDomino.dataset.boardOrientation || "";
        }
      
        // Save original DOM position (for snap-back or tray return)
        activeDomino.dataset.originalLeft = activeDomino.style.left || "";
        activeDomino.dataset.originalTop = activeDomino.style.top || "";
        activeDomino.dataset.originalParent = parent.id || "";
      
        // Clear occupancy for this domino
        Object.keys(boardOccupancy).forEach(key => {
          if (boardOccupancy[key] === activeDomino) {
            delete boardOccupancy[key];
          }
        });
        logBoardOccupancy();
      
        // Prepare drag offsets
        const clientX = e.touches ? e.touches[0].clientX : e.clientX;
        const clientY = e.touches ? e.touches[0].clientY : e.clientY;
      
        const preRect = activeDomino.getBoundingClientRect();
        offsetX = clientX - preRect.left;
        offsetY = clientY - preRect.top;
      
        const root = document.getElementById("pips-root");
        const rootRect = root.getBoundingClientRect();
      
        root.appendChild(activeDomino);
      
        activeDomino.style.position = "absolute";
        activeDomino.style.zIndex = 1000;
        activeDomino.style.left = `${clientX - offsetX - rootRect.left}px`;
        activeDomino.style.top  = `${clientY - offsetY - rootRect.top}px`;
      
        highlightPossibleCells(activeDomino);
      }

      /* ------------------------------
         DRAG MOVEMENT
         ------------------------------ */
      function drag(e) {
        if (!activeDomino) return;
      
        const clientX = e.touches ? e.touches[0].clientX : e.clientX;
        const clientY = e.touches ? e.touches[0].clientY : e.clientY;
      
        const rootRect = document.getElementById("pips-root").getBoundingClientRect();
      
        activeDomino.style.left = `${clientX - offsetX - rootRect.left}px`;
        activeDomino.style.top  = `${clientY - offsetY - rootRect.top}px`;
      }

      /* ------------------------------
         END DRAG → TRY TO PLACE
         ------------------------------ */
      function endDrag(e) {
        if (!activeDomino) return;
      
        clearHighlights();
      
        const placed = tryPlaceDomino(activeDomino);
      
        if (placed) {
          // CASE A — valid placement
          activeDomino = null;
          return;
        }
      
        const cameFromBoard = activeDomino.dataset.origin === "board";
        const attempt = activeDomino.dataset.dropAttempt || "off-board";
      
        if (attempt === "invalid-on-board" && cameFromBoard) {
          // CASE B — invalid board placement, snap back to previous board position
          const root = document.getElementById("pips-root");
          const rootRect = root.getBoundingClientRect();
      
          const prevRow = parseInt(activeDomino.dataset.prevRow, 10);
          const prevCol = parseInt(activeDomino.dataset.prevCol, 10);
          const prevOrientation = activeDomino.dataset.prevOrientation;
      
          const anchorCell = document.getElementById(`cell-${prevRow}-${prevCol}`);
          const anchorRect = anchorCell.getBoundingClientRect();
      
          activeDomino.style.left = `${anchorRect.left - rootRect.left}px`;
          activeDomino.style.top  = `${anchorRect.top  - rootRect.top}px`;
      
          const cells = prevOrientation === "vertical"
            ? [ [prevRow, prevCol], [prevRow + 1, prevCol] ]
            : [ [prevRow, prevCol], [prevRow, prevCol + 1] ];
      
          cells.forEach(([r, c]) => {
            boardOccupancy[`${r},${c}`] = activeDomino;
          });
      
          logBoardOccupancy();
        } else {
          // CASE C — off-board OR invalid from tray → return to tray
          const home = document.getElementById(activeDomino.dataset.homeSlot);
          home.appendChild(activeDomino);
      
          activeDomino.style.position = "";
          activeDomino.style.left = "";
          activeDomino.style.top = "";
          activeDomino.style.zIndex = "";
      
          // Clear board position data
          delete activeDomino.dataset.boardRow;
          delete activeDomino.dataset.boardCol;
          delete activeDomino.dataset.boardOrientation;
        }
      
        activeDomino = null;
      }

      /* ============================================================
         PLACEMENT LOGIC
         ============================================================ */
      function tryPlaceDomino(domino) {
        const root = document.getElementById("pips-root");
        const rootRect = root.getBoundingClientRect();
      
        const rawDom = domino.getBoundingClientRect();
        const domRect = {
          left:   rawDom.left   - rootRect.left,
          right:  rawDom.right  - rootRect.left,
          top:    rawDom.top    - rootRect.top,
          bottom: rawDom.bottom - rootRect.top,
          width:  rawDom.width,
          height: rawDom.height
        };
      
        const leftHalf = {
          left: domRect.left,
          right: domRect.left + domRect.width / 2,
          top: domRect.top,
          bottom: domRect.bottom
        };
      
        let bestCells = [];
        let bestOverlap = 0;
      
        document.querySelectorAll(".pips-cell").forEach(cell => {
          const raw = cell.getBoundingClientRect();
          const rect = {
            left:   raw.left   - rootRect.left,
            right:  raw.right  - rootRect.left,
            top:    raw.top    - rootRect.top,
            bottom: raw.bottom - rootRect.top
          };
      
          const overlapLeft   = Math.max(leftHalf.left, rect.left);
          const overlapRight  = Math.min(leftHalf.right, rect.right);
          const overlapTop    = Math.max(leftHalf.top, rect.top);
          const overlapBottom = Math.min(leftHalf.bottom, rect.bottom);
      
          const overlapWidth  = overlapRight - overlapLeft;
          const overlapHeight = overlapBottom - overlapTop;
      
          if (overlapWidth > 0 && overlapHeight > 0) {
            const area = overlapWidth * overlapHeight;
      
            if (area > bestOverlap) {
              bestOverlap = area;
              bestCells = [cell];
            } else if (Math.abs(area - bestOverlap) < 0.001) {
              bestCells.push(cell);
            }
          }
        });
      
        // OFF-BOARD: no anchor cell
        if (bestCells.length === 0) {
          domino.dataset.dropAttempt = "off-board";
          return false;
        }
      
        const anchor = bestCells[0];
        const anchorRect = anchor.getBoundingClientRect();
        const minArea = (anchorRect.width * anchorRect.height) * 0.25;
      
        // OFF-BOARD: overlap too small
        if (bestOverlap < minArea) {
          domino.dataset.dropAttempt = "off-board";
          return false;
        }
      
        const row = parseInt(anchor.dataset.row, 10);
        const col = parseInt(anchor.dataset.col, 10);
        const vertical = domino.classList.contains("vertical");
      
        const cells = vertical
          ? [ [row, col], [row + 1, col] ]
          : [ [row, col], [row, col + 1] ];
      
        // OFF-BOARD: target cells off-grid
        for (const [r, c] of cells) {
          if (!document.getElementById(`cell-${r}-${c}`)) {
            domino.dataset.dropAttempt = "off-board";
            return false;
          }
        }
      
        // INVALID-ON-BOARD: overlap with another domino
        for (const [r, c] of cells) {
          const key = `${r},${c}`;
          if (boardOccupancy[key] && boardOccupancy[key] !== domino) {
            domino.dataset.dropAttempt = "invalid-on-board";
            return false;
          }
        }
      
        // VALID PLACEMENT
        domino.style.left = `${anchorRect.left - rootRect.left}px`;
        domino.style.top  = `${anchorRect.top  - rootRect.top}px`;
      
        cells.forEach(([r, c]) => {
          boardOccupancy[`${r},${c}`] = domino;
        });
      
        domino.dataset.boardRow = row;
        domino.dataset.boardCol = col;
        domino.dataset.boardOrientation = vertical ? "vertical" : "horizontal";
      
        domino.dataset.dropAttempt = "valid";
        logBoardOccupancy();
        return true;
      }
    
      /* ------------------------------
         VALIDATION HELPERS
         ------------------------------ */
      function flashInvalid(domino) {
        domino.classList.add("cell-invalid");
        setTimeout(() => domino.classList.remove("cell-invalid"), 300);
      }
      
      /* ============================================================
         HIGHLIGHTING
         ============================================================ */
      function highlightPossibleCells(domino) {
        const grid = document.getElementById("pips-grid");
        if (!grid) return;
      
        const cells = grid.querySelectorAll(".pips-cell");
        cells.forEach(cell => cell.classList.add("cell-highlight"));
      }
      
      function clearHighlights() {
        document.querySelectorAll(".cell-highlight").forEach(c =>
          c.classList.remove("cell-highlight")
        );
      }
  
      function checkWin() {
        // Count how many cells are occupied
        const keys = Object.keys(boardOccupancy);
      
        // A full 7×8 board has 56 cells → 28 dominos × 2 cells each
        if (keys.length !== 56) return false;
      
        // Ensure every cell is filled by a domino object
        for (const key of keys) {
          if (!boardOccupancy[key]) return false;
        }
      
        // Ensure each domino occupies exactly two cells
        const dominoCellCount = {};
        for (const key of keys) {
          const dom = boardOccupancy[key];
          dominoCellCount[dom.dataset.index] =
            (dominoCellCount[dom.dataset.index] || 0) + 1;
        }
      
        for (const index in dominoCellCount) {
          if (dominoCellCount[index] !== 2) return false;
        }
      
        return true;
      }

      function serializeBoard() {
        const state = [];
      
        document.querySelectorAll(".domino").forEach(dom => {
          if (!dom.dataset.boardRow) return; // skip tray dominos
      
          state.push({
            index: dom.dataset.index,
            row: parseInt(dom.dataset.boardRow, 10),
            col: parseInt(dom.dataset.boardCol, 10),
            orientation: dom.dataset.boardOrientation
          });
        });
      
        return state;
      }

      function loadBoardState(state) {
        // Clear occupancy
        Object.keys(boardOccupancy).forEach(key => delete boardOccupancy[key]);
      
        // Reset all dominos to tray
        document.querySelectorAll(".domino").forEach(dom => {
          const home = document.getElementById(dom.dataset.homeSlot);
          home.appendChild(dom);
      
          dom.style.position = "";
          dom.style.left = "";
          dom.style.top = "";
          dom.style.zIndex = "";
      
          delete dom.dataset.boardRow;
          delete dom.dataset.boardCol;
          delete dom.dataset.boardOrientation;
        });
      
        const root = document.getElementById("pips-root");
        const rootRect = root.getBoundingClientRect();
      
        // Apply saved placements
        state.forEach(entry => {
          const dom = document.querySelector(`.domino[data-index="${entry.index}"]`);
          const anchor = document.getElementById(`cell-${entry.row}-${entry.col}`);
          const anchorRect = anchor.getBoundingClientRect();
      
          root.appendChild(dom);
      
          dom.style.position = "absolute";
          dom.style.left = `${anchorRect.left - rootRect.left}px`;
          dom.style.top  = `${anchorRect.top  - rootRect.top}px`;
      
          dom.dataset.boardRow = entry.row;
          dom.dataset.boardCol = entry.col;
          dom.dataset.boardOrientation = entry.orientation;
      
          const cells = entry.orientation === "vertical"
            ? [ [entry.row, entry.col], [entry.row + 1, entry.col] ]
            : [ [entry.row, entry.col], [entry.row, entry.col + 1] ];
      
          cells.forEach(([r, c]) => {
            boardOccupancy[`${r},${c}`] = dom;
          });
        });
      
        logBoardOccupancy();
      }


  </script>

</body>
</html>
